# RHOM School Management - Production Deployment Checklist

This document outlines the essential steps and best practices for deploying the RHOM School Management application to a live, production environment. Following this checklist will help ensure a smooth, secure, and successful launch.

---

## 1. Environment Variables (`.env.local` or Provider UI)

Before deploying, you must configure your environment variables for the production build. Create a `.env.local` file in your project root or add these variables directly in your hosting provider's UI (e.g., Netlify, Vercel).

**Important:** You must replace the placeholder values below with the actual configuration values from your Firebase project settings. You can find these in the Firebase Console under **Project settings > General > Your apps > Firebase SDK snippet > Config**.

```
# Firebase Public Configuration
# These are safe to expose to the client.
# Replace with your actual Firebase project configuration for 'schoolmanagementsaas'.
NEXT_PUBLIC_FIREBASE_API_KEY=AIza...
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=schoolmanagementsaas.firebaseapp.com
NEXT_PUBLIC_FIREBASE_PROJECT_ID=schoolmanagementsaas
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=schoolmanagementsaas.appspot.com
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=...
NEXT_PUBLIC_FIREBASE_APP_ID=1:..:web:...
NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID=G-...
```

**Action:**
- [ ] Create the `.env.local` file or configure variables in your deployment provider's dashboard.
- [ ] Populate the variables with your **production** Firebase project's configuration values.

---

## 2. Firebase Backend Deployment & Configuration

Your Firestore database, authentication, and security rules need to be configured for production.

- **Firestore Indexes:** While developing, the emulator may create indexes automatically. In production, you must create composite indexes in the Firebase console for complex queries (e.g., sorting and filtering on different fields). The Firebase console will provide error messages with direct links to create any missing indexes when you run your application.
- **Firebase Authentication:**
    - In the Firebase Console, go to **Authentication > Sign-in method**.
    - Ensure **Email/Password** and **Anonymous** providers are enabled.
    - Manually create the initial **master** user account via the Firebase console.
- **Security Rules Deployment:** Deploy your `firestore.rules` file using the Firebase Command Line Interface (CLI).
    ```bash
    # Install the Firebase CLI if you haven't already
    npm install -g firebase-tools

    # Login to your Firebase account
    firebase login

    # Set your project (only need to do this once per directory)
    firebase use schoolmanagementsaas

    # Deploy only the Firestore rules
    firebase deploy --only firestore:rules
    ```
- **Cloud Functions (Manual Setup Required):**
    - **Critical:** This application's security model relies on Firebase Cloud Functions to set custom claims (`role`, `schoolId`, `subscriptionActive`) for users. These cannot be generated by the AI.
    - You must manually create and deploy Node.js functions using the `firebase-admin` SDK.
    - **Key Functions to Create:**
        1.  An `onUserCreate` function to assign default claims to new users.
        2.  An `onCall` function for the 'master' or 'admin' role to update other users' claims (e.g., assign roles).
        3.  A scheduled function (`pub/sub`) to periodically check for expired school subscriptions and update the `subscriptionActive` claim for all affected users.

**Action:**
- [ ] Review and create necessary Firestore indexes in the Firebase Console.
- [ ] Enable Email/Password and Anonymous auth providers.
- [ ] Create the `master` user account.
- [ ] Deploy `firestore.rules` using the Firebase CLI.
- [ ] **Manually write and deploy the required Cloud Functions for setting custom claims.**

---

## 3. Frontend Deployment (Netlify Example)

This guide uses Netlify as an example, but the steps are similar for other providers like Vercel or Firebase App Hosting.

- **Connect Git Repository:** Link your GitHub, GitLab, or Bitbucket repository to a new Netlify site.
- **Build Settings:** Netlify typically auto-detects Next.js projects. Ensure the settings are correct:
    - **Build command:** `npm run build` or `next build`
    - **Publish directory:** `.next`
- **Environment Variables:** Add the Firebase configuration variables from Step 1 to your Netlify site's environment variables (**Site settings > Build & deploy > Environment**).

**Action:**
- [ ] Connect your Git repository to Netlify.
- [ ] Verify build settings.
- [ ] Add all `NEXT_PUBLIC_` environment variables to Netlify's dashboard.
- [ ] Trigger your first deployment.

---

## 4. Security & Role Verification

After deployment, rigorously test the security rules and custom claims logic.

- **Custom Claims:**
    - [ ] Verify that a newly signed-up user (student/teacher) is correctly assigned their default claims.
    - [ ] As an `admin`, try to change a user's role. Verify the claims update correctly after they log out and log back in.
- **Cross-School Access:**
    - [ ] Log in as a `student` from "School A".
    - [ ] Attempt to access a Firestore document path belonging to "School B" using the browser's developer console. The request must be denied by Firestore rules.
- **Role-Based Access:**
    - [ ] Log in as a `teacher`. Attempt to perform an `admin`-only action, like publishing a result. The UI should hide the control, and any direct API/Firestore call must be denied.
- **Subscription Block:**
    - [ ] Manually set a school's subscription to be inactive (e.g., in your `schools` collection).
    - [ ] Trigger the Cloud Function that syncs subscription status to claims.
    - [ ] Log in as a user from that school. All data access should be blocked, and the UI should reflect this.

---

## 5. Multi-School Functional Testing Checklist

Perform an end-to-end test for at least two different schools to ensure complete data isolation.

- **School A & B Setup:**
    - [ ] As `master`, create "School A" and "School B".
    - [ ] Create an active subscription for both schools.
    - [ ] Create an `admin` user for each school.
- **School A - Workflow:**
    - [ ] Log in as `admin` for "School A".
    - [ ] Create one `teacher` and one `student`.
    - [ ] Log in as the `teacher` and enter marks for the student (should be unpublished).
    - [ ] Log in as the `student` and verify they **cannot** see the result.
    - [ ] As the `student`, submit a payment request.
- **School B - Workflow:**
    - [ ] Log in as `admin` for "School B" and verify you **cannot** see any data (students, teachers, payments) from "School A".
    - [ ] Create a `student` for "School B".
- **School A - Finalization:**
    - [ ] Log in as `admin` for "School A". Approve the student's payment.
    - [ ] Publish the student's result.
    - [ ] Create and publish a notice.
- **Final Verification:**
    - [ ] Log in as the `student` from "School A". Verify they **can** now see their result, download their payment receipt, and view the notice.
    - [ ] Log in as the `student` from "School B" and verify they **cannot** see any results or notices from "School A".
